// Copyright 2020 Anthony F. Stuart - All rights reserved.
//
// This program and the accompanying materials are made available
// under the terms of the GNU General Public License. For other license
// options please contact the copyright owner.
//
// This program is made available on an "as is" basis, without
// warranties or conditions of any kind, either express or implied.


#include "ysw_keyboard.h"
#include "ysw_common.h"
#include "ysw_event.h"
#include "ysw_heap.h"
#include "ysw_task.h"
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "freertos/queue.h"
#include "driver/gpio.h"
#include "esp_log.h"

#define TAG "YSW_KEYBOARD"

#define LOW 0
#define HIGH 1

// Layout of keycodes generated by keyboard:
//
//    0,  1,      2,  3,  4,      5,  6,  7,  8,
//  9, 10, 11, 12, 13, 14, 15,   16, 17, 18, 19,
//   20, 21,     22, 23, 24,     25, 26, 27, 28,
// 29, 30, 31, 32, 33, 34, 35,   36, 37, 38, 39,

typedef struct {
    uint32_t down_time;
    uint32_t repeat_count;
} state_t;

typedef struct {
    ysw_bus_t *bus;
    ysw_array_t *rows;
    ysw_array_t *columns;
    state_t state[];
} ysw_keyboard_t;

static void configure_row(uint8_t gpio)
{
    ESP_LOGD(TAG, "configure_row gpio=%d", gpio);
    gpio_config_t config = {
        .pin_bit_mask = 1ull << gpio,
        .mode = GPIO_MODE_INPUT,
        .pull_up_en = GPIO_PULLUP_ENABLE,
        .pull_down_en = 0,
        .intr_type = GPIO_INTR_DISABLE,
    };

    $(gpio_config(&config));
}

static void configure_column(uint8_t gpio)
{
    ESP_LOGD(TAG, "configure_column gpio=%d", gpio);
    gpio_config_t config = {
        .pin_bit_mask = 1ull << gpio,
        .mode = GPIO_MODE_OUTPUT,
        .pull_up_en = 0,
        .pull_down_en = 0,
        .intr_type = GPIO_INTR_DISABLE,
    };

    $(gpio_config(&config));
    $(gpio_set_level(gpio, HIGH));
}

static void on_key_pressed(ysw_bus_t *bus, uint8_t scan_code, state_t *state)
{
    //ESP_LOGD(TAG, "col=%d, row=%d, scan_code=%d", column_index, row_index, scan_code);
    uint32_t current_millis = ysw_get_millis();
    if (!state->down_time) {
        state->repeat_count = 0;
        state->down_time = current_millis;
        ysw_event_key_down_t key_down = {
            .scan_code = scan_code,
            .time = state->down_time,
        };
        ysw_event_fire_key_down(bus, &key_down);
    } else if (state->down_time + ((state->repeat_count + 1) * 100) < current_millis) {
        state->repeat_count++;
        ysw_event_key_pressed_t key_pressed = {
            .scan_code = scan_code,
            .time = state->down_time,
            .duration = current_millis - state->down_time,
            .repeat_count = state->repeat_count,
        };
        ysw_event_fire_key_pressed(bus, &key_pressed);
    }
}

static void on_key_released(ysw_bus_t *bus, uint8_t scan_code, state_t *state)
{
    uint32_t current_millis = ysw_get_millis();
    uint32_t duration = current_millis - state->down_time;
    if (!state->repeat_count) {
        ysw_event_key_pressed_t key_pressed = {
            .scan_code = scan_code,
            .time = state->down_time,
            .duration = duration,
            .repeat_count = state->repeat_count,
        };
        ysw_event_fire_key_pressed(bus, &key_pressed);
    }
    ysw_event_key_up_t key_up = {
        .scan_code = scan_code,
        .time = state->down_time,
        .duration = duration,
        .repeat_count = state->repeat_count,
    };
    ysw_event_fire_key_up(bus, &key_up);
    state->down_time = 0;
}

static void scan_keyboard(ysw_keyboard_t *keyboard)
{
    uint32_t row_count = ysw_array_get_count(keyboard->rows);
    uint32_t column_count = ysw_array_get_count(keyboard->columns);
    //ESP_LOGD(TAG, "scan_keyboard row_count=%d, column_count=%d", row_count, column_count);
    for (uint32_t column_index = 0; column_index < column_count; column_index++) {
        uint8_t column_gpio = (uintptr_t)ysw_array_get(keyboard->columns, column_index);
        $(gpio_set_level(column_gpio, LOW));
        for (int row_index = 0; row_index < row_count; row_index++) {
            uint8_t scan_code = (row_index * column_count) + column_index;
            uint8_t row_gpio = (uintptr_t)ysw_array_get(keyboard->rows, row_index);
            int key_pressed = gpio_get_level(row_gpio) == LOW;
            if (key_pressed) {
                on_key_pressed(keyboard->bus, scan_code, &keyboard->state[scan_code]);
            } else if (keyboard->state[scan_code].down_time) {
                on_key_released(keyboard->bus,scan_code,  &keyboard->state[scan_code]);
            }
        }
        $(gpio_set_level(column_gpio, HIGH));
    }
}

static void process_event(void *context, ysw_event_t *event)
{
    ysw_keyboard_t *keyboard = context;
    if (event) {
        switch (event->header.type) {
            default:
                break;
        }
    }
    scan_keyboard(keyboard);
}

void ysw_keyboard_create_task(ysw_bus_t *bus, ysw_keyboard_config_t *keyboard_config)
{
    uint32_t row_count = ysw_array_get_count(keyboard_config->rows);
    ESP_LOGD(TAG, "ysw_keyboard_create_task row_count=%d", row_count);
    for (int row_index = 0; row_index < row_count; row_index++) {
        uint8_t row_gpio = (uintptr_t)ysw_array_get(keyboard_config->rows, row_index);
        configure_row(row_gpio);
    }

    uint32_t column_count = ysw_array_get_count(keyboard_config->columns);
    ESP_LOGD(TAG, "ysw_keyboard_create_task column_count=%d", column_count);
    for (int column_index = 0; column_index < column_count; column_index++) {
        uint8_t column_gpio = (uintptr_t)ysw_array_get(keyboard_config->columns, column_index);
        configure_column(column_gpio);
    }

    ysw_keyboard_t *keyboard = ysw_heap_allocate(sizeof(ysw_keyboard_t) +
            (sizeof(state_t) * row_count * column_count));

    keyboard->bus = bus;
    keyboard->rows = keyboard_config->rows;
    keyboard->columns = keyboard_config->columns;

    ysw_task_config_t config = ysw_task_default_config;

    config.name = TAG;
    config.bus = bus;
    config.event_handler = process_event;
    config.context = keyboard;
    config.wait_millis = 10;

    ysw_task_create(&config);
}
