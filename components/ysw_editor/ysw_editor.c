// Copyright 2020 Anthony F. Stuart - All rights reserved.
//
// This program and the accompanying materials are made available
// under the terms of the GNU General Public License. For other license
// options please contact the copyright owner.
//
// This program is made available on an "as is" basis, without
// warranties or conditions of any kind, either express or implied.


#include "ysw_editor.h"
#include "ysw_common.h"
#include "ysw_event.h"
#include "ysw_heap.h"
#include "ysw_staff.h"
#include "ysw_task.h"
#include "ysw_ticks.h"
#include "zm_music.h"
#include "lvgl.h"
#include "esp_log.h"
#include "assert.h"

#define TAG "EDITOR"

// Layout of keycodes generated by keyboard:
//
//    0,  1,      2,  3,  4,      5,  6,  7,  8,
//  9, 10, 11, 12, 13, 14, 15,   16, 17, 18, 19,
//   20, 21,     22, 23, 24,     25, 26, 27, 28,
// 29, 30, 31, 32, 33, 34, 35,   36, 37, 38, 39,

// Mapping of keycodes to note values and keypad values:

static const uint8_t key_map[] = {
    /* 1 */   13, 15,     18, 20, 22,     24, 25, 26, 27,
    /* 2 */ 12, 14, 16, 17, 19, 21, 23,   28, 29, 30, 31,
    /* 3 */    1,  3,      6,  8, 10,     32, 33, 34, 35,
    /* 4 */  0,  2,  4,  5,  7,  9, 11,   36, 37, 38, 39,
};

#define YSW_EDITOR_NOTES 24


#define YSW_EDITOR_NOTE 24
#define YSW_EDITOR_CHORD 25
#define YSW_EDITOR_DRUM 26

// chords
#define YSW_EDITOR_QUALITY 28
#define YSW_EDITOR_STYLE 29

// notes
#define YSW_EDITOR_REST 28
#define YSW_EDITOR_DURATION 29
#define YSW_EDITOR_KEY 30

#define YSW_EDITOR_DELETE 32
#define YSW_EDITOR_SAMPLE 33
#define YSW_EDITOR_BPM 34

#define YSW_EDITOR_UP 27
#define YSW_EDITOR_DOWN 31
#define YSW_EDITOR_LEFT 35
#define YSW_EDITOR_RIGHT 39

#define KEY_MAP_SZ (sizeof(key_map) / sizeof(key_map[0]))

typedef enum {
    YSW_EDITOR_MODE_NOTE,
    YSW_EDITOR_MODE_CHORD,
    YSW_EDITOR_MODE_DRUM,
} ysw_editor_mode_t;

// 0 % 2 = 0
// 1 % 2 = 1 C
// 2 % 2 = 0
// 3 % 2 = 1 E
// 4 % 2 = 0 
// 5 % 2 = 1 G
// 6 % 2 = 0

// position / 2 >= count ? space-after-note : position % 2 ? note index / 2 : space-before-note

typedef struct {
    ysw_bus_h bus;
    zm_music_t *music;
    zm_passage_t *passage;
    // defaults
    zm_duration_t duration;
    zm_quality_x quality;
    zm_style_x style;

    uint32_t position;
    uint8_t advance;
    lv_obj_t *container;
    lv_obj_t *header;
    lv_obj_t *staff;
    lv_obj_t *footer;
    ysw_editor_mode_t mode;
} context_t;

static void update_header(context_t *context)
{
    if (context->mode == YSW_EDITOR_MODE_NOTE) {
        // TODO: get measure from ysw_staff hints
        // Measure: 1/4 Key: D (2 sharps) Time: 4/4 Tempo: 100 BPM
        char buf[256];
        zm_key_signature_t key;
        zm_get_key_signature(context->passage->key, &key);
        snprintf(buf, sizeof(buf), "Key %s/%d BPM", key.name, context->passage->bpm);
        lv_label_set_text(context->header, buf);
    }
}

static void update_footer(context_t *context)
{
    if (context->mode == YSW_EDITOR_MODE_NOTE) {
        // Note: C5, Duration: 256, Sample: Steinway
        char buf[256];
        snprintf(buf, sizeof(buf), "Note: C5, Duration: 256, Sample: Steinway");
        lv_label_set_text(context->footer, buf);
    } else if (context->mode == YSW_EDITOR_MODE_CHORD) {
        // Chord: D Maj, Style: Arp1, Sample: Steinway
    }
}

static void update_details(context_t *context)
{
    update_header(context);
    update_footer(context);
}

static void process_note(context_t *context, ysw_event_key_up_t *event)
{
    zm_beat_t *beat = NULL;
    int32_t beat_index = context->position / 2;
    if (context->position % 2 == 0) {
        beat = ysw_heap_allocate(sizeof(zm_beat_t));
        ysw_array_insert(context->passage->beats, beat_index, beat);
    } else {
        beat = ysw_array_get(context->passage->beats, beat_index);
    }
    uint8_t value = key_map[event->key];
    beat->tone.note = value == YSW_EDITOR_REST ? 0 : 60 + value;
    if (context->duration == ZM_AS_PLAYED) {
        beat->tone.duration = ysw_millis_to_ticks(event->duration, context->passage->bpm);
    } else {
        beat->tone.duration = context->duration;
    }
    uint32_t beat_count = ysw_array_get_count(context->passage->beats);
    context->position = min(context->position + context->advance, beat_count * 2);
    ysw_staff_update_all(context->staff, context->position);
    update_details(context);
}

static void process_duration(context_t *context)
{
    if (context->position % 2 == 0) {
        if (context->duration == ZM_AS_PLAYED) {
            context->duration = ZM_SIXTEENTH;
        } else if (context->duration <= ZM_SIXTEENTH) {
            context->duration = ZM_EIGHTH;
        } else if (context->duration <= ZM_EIGHTH) {
            context->duration = ZM_QUARTER;
        } else if (context->duration <= ZM_QUARTER) {
            context->duration = ZM_HALF;
        } else if (context->duration <= ZM_HALF) {
            context->duration = ZM_WHOLE;
        } else {
            context->duration = ZM_AS_PLAYED;
        }
        update_details(context);
    } else {
        uint32_t beat_index = context->position / 2;
        zm_beat_t *beat = ysw_array_get(context->passage->beats, beat_index);
        beat->tone.duration = context->duration;
        ysw_staff_update_all(context->staff, context->position);
    }
}

static void process_delete(context_t *context)
{
    if (context->position % 2 == 1) {
        uint32_t beat_index = context->position / 2;
        zm_beat_t *beat = ysw_array_remove(context->passage->beats, beat_index);
        ysw_heap_free(beat);
        uint32_t beat_count = ysw_array_get_count(context->passage->beats);
        if (beat_index == beat_count) {
            if (beat_count) {
                context->position -= 2;
            } else {
                context->position = 0;
            }
        }
        ysw_staff_update_all(context->staff, context->position);
    }
}

static void process_left(context_t *context)
{
    if (context->position > 0) {
        context->position--;
        ysw_staff_update_position(context->staff, context->position);
    }
}

static void process_right(context_t *context)
{
    if (context->position < (ysw_array_get_count(context->passage->beats) * 2)) {
        context->position++;
        ysw_staff_update_position(context->staff, context->position);
    }
}

static void on_key_down(context_t *context, ysw_event_key_down_t *event)
{
    assert(event->key < KEY_MAP_SZ);
    uint8_t value = key_map[event->key];
    //ESP_LOGD(TAG, "on_key_down key=%d, value=%d", event->key, value);
    if (value < YSW_EDITOR_NOTES) {
        ysw_event_note_on_t note_on = {
            .channel = 0,
            .midi_note = 60 + value,
            .velocity = 80,
        };
        ysw_event_fire_note_on(context->bus, YSW_ORIGIN_EDITOR, &note_on);
    }
}

static void on_key_up(context_t *context, ysw_event_key_up_t *event)
{
    assert(event->key < KEY_MAP_SZ);
    uint8_t value = key_map[event->key];
    if (value < YSW_EDITOR_NOTES) {
        ysw_event_note_off_t note_off = {
            .channel = 0,
            .midi_note = 60 + value,
        };
        ysw_event_fire_note_off(context->bus, YSW_ORIGIN_EDITOR, &note_off);
    }
    if (value < YSW_EDITOR_NOTES || value == YSW_EDITOR_REST) {
        switch (context->mode) {
            case YSW_EDITOR_MODE_NOTE:
                process_note(context, event);
                break;
            case YSW_EDITOR_MODE_CHORD:
                break;
            case YSW_EDITOR_MODE_DRUM:
                break;
        }
    }
}

static void on_key_pressed(context_t *context, ysw_event_key_pressed_t *event)
{
    assert(event->key < KEY_MAP_SZ);
    uint8_t value = key_map[event->key];
    ESP_LOGD(TAG, "on_key_pressed key=%d, value=%d", event->key, value);
    switch (value) {
        case YSW_EDITOR_NOTE:
            context->mode = YSW_EDITOR_MODE_NOTE;
            update_details(context);
            break;
        case YSW_EDITOR_CHORD:
            //context->mode = YSW_EDITOR_MODE_CHORD;
            update_details(context);
            break;
        case YSW_EDITOR_DRUM:
            //context->mode = YSW_EDITOR_MODE_DRUM;
            update_details(context);
            break;
        case YSW_EDITOR_DURATION:
            process_duration(context);
            break;
        case YSW_EDITOR_KEY:
            context->passage->key = zm_get_next_key_index(context->passage->key);
            ysw_staff_update_all(context->staff, context->position);
            update_details(context);
            break;
        case YSW_EDITOR_DELETE:
            process_delete(context);
            break;
        case YSW_EDITOR_LEFT:
            process_left(context);
            break;
        case YSW_EDITOR_RIGHT:
            process_right(context);
            break;
        default:
            break;
    }
}

static void on_note_on(context_t *context, ysw_event_t *event)
{
    assert(event->header.origin == YSW_ORIGIN_SEQUENCER); // i.e. not from us
}

static void process_event(void *caller_context, ysw_event_t *event)
{
    context_t *context = caller_context;
    if (event) {
        switch (event->header.type) {
            case YSW_EVENT_KEY_DOWN:
                on_key_down(context, &event->key_down);
                break;
            case YSW_EVENT_KEY_UP:
                on_key_up(context, &event->key_up);
                break;
            case YSW_EVENT_KEY_PRESSED:
                on_key_pressed(context, &event->key_pressed);
                break;
            case YSW_EVENT_NOTE_ON:
                on_note_on(context, event);
                break;
            default:
                break;
        }
    }
    lv_task_handler();
}

void ysw_editor_create_task(ysw_bus_h bus, zm_music_t *music)
{
    context_t *context = ysw_heap_allocate(sizeof(context_t));

    context->bus = bus;
    context->music = music;
    context->duration = ZM_AS_PLAYED;
    context->quality = 0;
    context->style = 0;
    context->position = 0;
    context->advance = 2;
    context->mode = YSW_EDITOR_MODE_NOTE;

    context->passage = ysw_heap_allocate(sizeof(zm_passage_t));
    context->passage->beats = ysw_array_create(64);
    context->passage->bpm = 100;
    context->passage->key = 0;
    context->passage->time = ZM_TIME_4_4;

    context->container = lv_obj_create(lv_scr_act(), NULL);
    assert(context->container);
    lv_obj_set_size(context->container, 320, 240);
    lv_obj_align(context->container, NULL, LV_ALIGN_CENTER, 0, 0);

    context->header = lv_label_create(context->container, NULL);
    assert(context->header);
    lv_label_set_long_mode(context->header, LV_LABEL_LONG_BREAK);
    lv_label_set_align(context->header, LV_LABEL_ALIGN_CENTER);
    lv_obj_set_size(context->header, 320, 20);
    lv_obj_align(context->header, NULL, LV_ALIGN_IN_TOP_LEFT, 0, 0);

    context->staff = ysw_staff_create(context->container);
    assert(context->staff);
    lv_obj_set_size(context->staff, 320, 200);
    lv_obj_align(context->staff, NULL, LV_ALIGN_CENTER, 0, 0);
    ysw_staff_set_passage(context->staff, context->passage);

    context->footer = lv_label_create(context->container, NULL);
    assert(context->footer);
    lv_label_set_long_mode(context->footer, LV_LABEL_LONG_BREAK);
    lv_label_set_align(context->footer, LV_LABEL_ALIGN_CENTER);
    lv_obj_set_size(context->footer, 320, 20);
    lv_obj_align(context->footer, NULL, LV_ALIGN_IN_BOTTOM_LEFT, 0, 0);

    ysw_task_config_t config = ysw_task_default_config;

    config.name = TAG;
    config.bus = bus;
    config.event_handler = process_event;
    config.caller_context = context;
    config.wait_millis = 5;
    config.priority = YSW_TASK_DEFAULT_PRIORITY + 1;

    ysw_task_h task = ysw_task_create(&config);

    ysw_task_subscribe(task, YSW_ORIGIN_KEYBOARD);
    ysw_task_subscribe(task, YSW_ORIGIN_SEQUENCER);
}

