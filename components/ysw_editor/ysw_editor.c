// Copyright 2020 Anthony F. Stuart - All rights reserved.
//
// This program and the accompanying materials are made available
// under the terms of the GNU General Public License. For other license
// options please contact the copyright owner.
//
// This program is made available on an "as is" basis, without
// warranties or conditions of any kind, either express or implied.


#include "ysw_editor.h"
#include "ysw_common.h"
#include "ysw_event.h"
#include "ysw_heap.h"
#include "ysw_task.h"
#include "zm_music.h"
#include "lvgl.h"
#include "esp_log.h"
#include "assert.h"

#define TAG "EDITOR"

// Layout of keycodes generated by keyboard:
//
//    0,  1,      2,  3,  4,      5,  6,  7,  8,
//  9, 10, 11, 12, 13, 14, 15,   16, 17, 18, 19,
//   20, 21,     22, 23, 24,     25, 26, 27, 28,
// 29, 30, 31, 32, 33, 34, 35,   36, 37, 38, 39,

// Mapping of keycodes to note values and keypad values:

static const uint8_t key_map[] = {
    /* 1 */   13, 15,     18, 20, 22,     24, 25, 26, 27,
    /* 2 */ 12, 14, 16, 17, 19, 21, 23,   28, 29, 30, 31,
    /* 3 */    1,  3,      6,  8, 10,     32, 33, 34, 35,
    /* 4 */  0,  2,  4,  5,  7,  9, 11,   36, 37, 38, 39,
};

#define KEY_MAP_SZ (sizeof(key_map) / sizeof(key_map[0]))

// 0 % 2 = 0
// 1 % 2 = 1 C
// 2 % 2 = 0
// 3 % 2 = 1 E
// 4 % 2 = 0 
// 5 % 2 = 1 G
// 6 % 2 = 0

// position / 2 >= count ? space-after-note : position % 2 ? note index / 2 : space-before-note

// lv_label selection is currently broken:
// https://github.com/lvgl/lvgl/issues/1820
#define USE_RECOLOR_SELECTION 1

typedef struct {
    ysw_bus_h bus;
    zm_passage_t *passage;
    uint32_t position;
    bool is_insert;
#if 0
    lv_obj_t *staff;
#endif
    lv_obj_t *page;
    lv_obj_t *label;
} context_t;

static const char *lookup[] = {
    // C,      #C,   D,        #D,   E,   F,         #F,    G,        #G,   A,        #A,   B
    "R", "\u00d2R", "S", "\u00d3S", "T", "U",  "\u00d5U",  "V", "\u00d6V", "W", "\u00d7W", "X",
    "Y", "\u00d9Y", "Z", "\u00daZ", "[", "\\", "\u00dc\\", "]", "\u00dd]", "^", "\u00de^", "_",
};

static void on_note_on(context_t *context, ysw_event_note_on_t *event)
{
}

static void update_passage(context_t *context)
{
    uint32_t beat_count = ysw_array_get_count(context->passage->beats);
    uint32_t symbol_count = beat_count * 2;
    uint32_t size = (symbol_count * 2) + 20; // * 2 for max strlen(lookup[i]) and + 10 for prefix + color
    char buffer[size];
    char *p = buffer;
    *p++ = '\'';
    *p++ = '&';
    *p++ = '='; // key signature
    *p++ = '4'; // time signature
    *p++ = '=';

#if USE_RECOLOR_SELECTION
#else
    uint32_t sel_start = LV_DRAW_LABEL_NO_TXT_SEL;
    uint32_t sel_end = LV_DRAW_LABEL_NO_TXT_SEL;
#endif

    for (int i = 0; i <= symbol_count; i++) { // = to get trailing space
        if (i == context->position) {
#if USE_RECOLOR_SELECTION
            const char *q = "#ff0000 ";
            while (*q) {
                *p++ = *q++;
            }
#else
            sel_start = p - buffer;
#endif
        }
        if (i % 2 == 0) {
            *p++ = '=';
        } else {
            uint32_t beat_index = i / 2;
            zm_beat_t *beat = ysw_array_get(context->passage->beats, beat_index);
            if (beat->tone.note) {
                const char *q = lookup[beat->tone.note - 60];
                while (*q) {
                    *p++ = *q++;
                }
            } else {
                // rest
            }
        }
        if (i == context->position) {
#if USE_RECOLOR_SELECTION
            *p++ = '#';
#else
            sel_end = p - buffer;
#endif
        }
    }
    *p = 0;
    ESP_LOGD(TAG, "buffer=%s", buffer);
    lv_label_set_text(context->label, buffer);
#if USE_RECOLOR_SELECTION
    lv_coord_t width = lv_obj_get_width(context->label);
    lv_coord_t dist = max(width - 180, 0);
    ESP_LOGD(TAG, "width=%d, dist=%d", width, dist);
    //lv_page_scroll_hor(context->page, -dist);
    lv_obj_t *scrl = lv_page_get_scrollable(context->page);
    lv_obj_set_x(scrl, lv_obj_get_x(scrl) - dist);
#else 
    lv_label_set_text_sel_start(context->label, sel_start);
    lv_label_set_text_sel_end(context->label, sel_end);
#endif
}

static void on_key_down(context_t *context, ysw_event_key_down_t *event)
{
    assert(event->key < KEY_MAP_SZ);
    uint8_t value = key_map[event->key];
    ESP_LOGD(TAG, "key=%d, value=%d", event->key, value);
    if (value < 24) {
        ysw_event_fire_note_on(context->bus, 0, 60 + value, 80);
    }
}

static void on_key_up(context_t *context, ysw_event_key_up_t *event)
{
    assert(event->key < KEY_MAP_SZ);
    uint8_t value = key_map[event->key];
    if (value < 24) {
        ysw_event_fire_note_off(context->bus, 0, 60 + value);
    }
}

static void on_key_pressed(context_t *context, ysw_event_key_pressed_t *event)
{
    assert(event->key < KEY_MAP_SZ);
    uint8_t value = key_map[event->key];
    ESP_LOGD(TAG, "key=%d, value=%d", event->key, value);
    if (value < 24) {
        int32_t beat_index = context->position / 2;
        if (context->position % 2 == 0) {
            zm_beat_t *beat = ysw_heap_allocate(sizeof(zm_beat_t));
            beat->tone.note = 60 + value;
            ysw_array_insert(context->passage->beats, beat_index, beat);
            if (context->is_insert) {
                context->position += 2; // move from space to next space
            } else {
                context->position += 1; // move from space to note
            }
        } else {
            zm_beat_t *beat = ysw_array_get(context->passage->beats, beat_index);
            beat->tone.note = 60 + value;
            if (context->is_insert) {
                context->position += 1;
            }
        }
    } else if (value == 35) {
        if (context->position > 0) {
            context->position--;
        }
    } else if (value == 39) {
        if (context->position < (ysw_array_get_count(context->passage->beats) * 2)) {
            context->position++;
        }
    } else {
        return;
    }
    update_passage(context);
}

static void on_play(context_t *context, ysw_event_play_t *event)
{
#if 0
    ysw_staff_set_notes(context->staff, event->clip.notes);
#endif
}

static void process_event(void *caller_context, ysw_event_t *event)
{
    context_t *context = caller_context;
    if (event) {
        switch (event->header.type) {
            case YSW_EVENT_KEY_DOWN:
                on_key_down(context, &event->key_down);
                break;
            case YSW_EVENT_KEY_UP:
                on_key_up(context, &event->key_up);
                break;
            case YSW_EVENT_KEY_PRESSED:
                on_key_pressed(context, &event->key_pressed);
                break;
            case YSW_EVENT_PLAY:
                on_play(context, &event->play);
                break;
            case YSW_EVENT_NOTE_ON:
                on_note_on(context, &event->note_on);
                break;
            default:
                break;
        }
    }
    lv_task_handler();
}

void ysw_editor_create_task(ysw_bus_h bus)
{
    context_t *context = ysw_heap_allocate(sizeof(context_t));

    context->bus = bus;
    context->passage = ysw_heap_allocate(sizeof(zm_passage_t));
    context->passage->beats = ysw_array_create(64);
    context->position = 0;
    context->is_insert = true;

    context->page = lv_page_create(lv_scr_act(), NULL);
    lv_obj_set_size(context->page, 320, 240);
    lv_obj_align(context->page, NULL, LV_ALIGN_CENTER, 0, 0);

    context->label = lv_label_create(context->page, NULL);
    lv_obj_set_style_local_text_font(context->label, LV_OBJ_PART_MAIN, LV_STATE_DEFAULT, &MusiQwik_48);
    lv_obj_set_style_local_text_sel_color(context->label, LV_OBJ_PART_MAIN, LV_STATE_DEFAULT, LV_COLOR_GREEN);
    lv_label_set_recolor(context->label, true);
    lv_label_set_text(context->label, "'&=4=");

#if 0
    context->staff = ysw_staff_create(lv_scr_act());
    lv_obj_set_size(context->staff, 320, 240);
    lv_obj_align(context->staff, NULL, LV_ALIGN_CENTER, 0, 0);
#endif
#if 0
    extern void lv_demo_widgets(void);
    lv_demo_widgets();
#endif

    ysw_task_config_t config = ysw_task_default_config;

    config.name = TAG;
    config.bus = bus;
    config.event_handler = process_event;
    config.caller_context = context;
    config.wait_millis = 5;
    config.priority = YSW_TASK_DEFAULT_PRIORITY + 1;

    ysw_task_h task = ysw_task_create(&config);

    ysw_task_subscribe(task, YSW_ORIGIN_KEYBOARD);
    ysw_task_subscribe(task, YSW_ORIGIN_COMMAND);
    ysw_task_subscribe(task, YSW_ORIGIN_NOTE);
}

