// Copyright 2020 Anthony F. Stuart - All rights reserved.
//
// This program and the accompanying materials are made available
// under the terms of the GNU General Public License. For other license
// options please contact the copyright owner.
//
// This program is made available on an "as is" basis, without
// warranties or conditions of any kind, either express or implied.

#include "ysw_tty.h"
#include "ysw_common.h"
#include "ysw_event.h"
#include "ysw_heap.h"
#include "ysw_task.h"
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "freertos/queue.h"
#include "driver/gpio.h"
#include "esp_log.h"

#define TAG "YSW_TTY"

#define LOW 0
#define HIGH 1

typedef enum {
    S_INITIAL,
    S_ESC,
    S_ESC_LSB,
    S_ESC_LSB_3,
} ysw_tty_state_t;

typedef struct {
    ysw_bus_t *bus;
    ysw_tty_state_t state;
} ysw_tty_t;

// Layout of keycodes generated by mm v02 keyboard:
//
//    0,  1,      2,  3,  4,      5,  6,  7,  8,
//  9, 10, 11, 12, 13, 14, 15,   16, 17, 18, 19,
//   20, 21,     22, 23, 24,     25, 26, 27, 28,
// 29, 30, 31, 32, 33, 34, 35,   36, 37, 38, 39,

// Layout of keycodes generated by miniterm.py with NumLock on:
// Use shift with digit row to distinguish from digits on numeric keypad
// Use BS instead of NumLock because NumLock does not send a code
//
//    @,  #,      %,  ^,  &,     BS,  /,  *,  -,
//  q,  w,  e,  r,  t,  y,  u,    7,  8,  9,  +,
//    s,  d,      g,  h,  j,      4,  5,  6, NL,
//  z,  x,  c,  v,  b,  n,  m,    1,  2,  3,  0,

// Special Keys:
// up (8)
// down (19)
// left (28)
// right (39)
// delete (37)

#define BS 8
#define NL 10
#define ESC 27

typedef struct {
    char input;
    uint8_t scan_code;
} keycode_map_t;

static const keycode_map_t scan_code_map[] = {
	{ '@', 0 },
	{ '#', 1 },
	{ '%', 2 },
	{ '^', 3 },
	{ '&', 4 },
	{ BS, 5 },
	{ '/', 6 },
	{ '*', 7 },
	{ '-', 8 },
	{ 'q', 9 },
	{ 'w', 10 },
	{ 'e', 11 },
	{ 'r', 12 },
	{ 't', 13 },
	{ 'y', 14 },
	{ 'u', 15 },
	{ '7', 16 },
	{ '8', 17 },
	{ '9', 18 },
	{ '+', 19 },
	{ 's', 20 },
	{ 'd', 21 },
	{ 'g', 22 },
	{ 'h', 23 },
	{ 'j', 24 },
	{ '4', 25 },
	{ '5', 26 },
	{ '6', 27 },
	{ NL, 28 },
	{ 'z', 29 },
	{ 'x', 30 },
	{ 'c', 31 },
	{ 'v', 32 },
	{ 'b', 33 },
	{ 'n', 34 },
	{ 'm', 35 },
	{ '1', 36 },
	{ '2', 37 },
	{ '3', 38 },
	{ '0', 39 },
};

#define KEYCODE_MAP_SZ (sizeof(scan_code_map) / sizeof(scan_code_map[0]))

static int find_scan_code(char input)
{
    for (int i = 0; i < KEYCODE_MAP_SZ; i++) {
        if (scan_code_map[i].input == input) {
            return scan_code_map[i].scan_code;
        }
    }
    return -1;
}

static void fire_key_events(ysw_tty_t *tty, uint8_t scan_code)
{
    uint32_t current_millis = ysw_get_millis();
    ysw_event_key_down_t key_down = {
        .scan_code = scan_code,
        .time = current_millis - 250,
    };
    ysw_event_fire_key_down(tty->bus, &key_down);
    ysw_event_key_pressed_t key_pressed = {
        .scan_code = scan_code,
        .time = current_millis,
        .duration = 250,
        .repeat_count = 0,
    };
    ysw_event_fire_key_pressed(tty->bus, &key_pressed);
    ysw_event_key_up_t key_up = {
        .scan_code = scan_code,
        .time = current_millis,
        .duration = 250,
        .repeat_count = 0,
    };
    ysw_event_fire_key_up(tty->bus, &key_up);
}

static void scan_tty(ysw_tty_t *tty)
{
    int c = getchar();
    if (c != -1) {
        int scan_code = -1;
        switch (tty->state) {
            case S_INITIAL:
                if (c == ESC) {
                    tty->state = S_ESC;
                } else {
                    scan_code = find_scan_code(c);
                }
                break;
            case S_ESC:
                if (c == '[') {
                    tty->state = S_ESC_LSB;
                } else {
                    tty->state = S_INITIAL;
                }
                break;
            case S_ESC_LSB:
                switch (c) {
                    case 'A': // UP
                        scan_code = 8;
                        break;
                    case 'D': // LEFT
                        scan_code = 28;
                        break;
                    case 'C': // RIGHT
                        scan_code = 39;
                        break;
                    case 'B': // DOWN
                        scan_code = 19;
                        break;
                    case '3':
                        tty->state = S_ESC_LSB_3;
                        break;
                    default:
                        tty->state = S_INITIAL;
                        break;
                }
                break;
            case S_ESC_LSB_3:
                switch (c) {
                    case '~': // DEL
                        scan_code = 37;
                        break;
                    default:
                        tty->state = S_INITIAL;
                        break;
                }
                break;
        }
        if (scan_code != -1) {
            ESP_LOGD(TAG, "c=%c/%d/%#x, scan_code=%d", c, c, c, scan_code);
            fire_key_events(tty, scan_code);
        } else {
            ESP_LOGD(TAG, "c=%c/%d/%#x", c, c, c);
        }
    }
}

static void process_event(void *context, ysw_event_t *event)
{
    ysw_tty_t *tty = context;
    if (event) {
        switch (event->header.type) {
            default:
                break;
        }
    }
    scan_tty(tty);
}

void ysw_tty_create_task(ysw_bus_t *bus)
{
    ysw_tty_t *tty = ysw_heap_allocate(sizeof(ysw_tty_t));
    tty->bus = bus;

    ysw_task_config_t config = ysw_task_default_config;
    config.name = TAG;
    config.bus = bus;
    config.event_handler = process_event;
    config.context = tty;
    config.wait_millis = 10;

    ysw_task_create(&config);
}
