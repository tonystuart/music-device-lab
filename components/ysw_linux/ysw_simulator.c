// Copyright 2020 Anthony F. Stuart - All rights reserved.
//
// This program and the accompanying materials are made available
// under the terms of the GNU General Public License. For other license
// options please contact the copyright owner.
//
// This program is made available on an "as is" basis, without
// warranties or conditions of any kind, either express or implied.

#include "ysw_bus.h"
#include "ysw_event.h"
#include "esp_log.h"
#include "stdint.h"

#define TAG "SIMULATOR"

typedef void (*lv_key_handler)(uint8_t key, uint32_t time, uint8_t repeat);
extern lv_key_handler lv_key_down_handler;
extern lv_key_handler lv_key_up_handler;
static uint32_t down_time;
static ysw_bus_h cb_bus;

// Layout of keycodes generated by keyboard:
//
//    0,  1,      2,  3,  4,      5,  6,  7,  8,
//  9, 10, 11, 12, 13, 14, 15,   16, 17, 18, 19,
//   20, 21,     22, 23, 24,     25, 26, 27, 28,
// 29, 30, 31, 32, 33, 34, 35,   36, 37, 38, 39,

typedef struct {
    char input;
    uint8_t key;
} keycode_map_t;

static const keycode_map_t keycode_map[] = {
    { '@', 0 },
    { '#', 1 },
    { '%', 2 },
    { '^', 3 },
    { '&', 4 },
    { '*', 5 },
    { 'q', 9 },
    { 'w', 10 },
    { 'e', 11 },
    { 'r', 12 },
    { 't', 13 },
    { 'y', 14 },
    { 'u', 15 },
    { 's', 20 },
    { 'd', 21 },
    { 'g', 22 },
    { 'h', 23 },
    { 'j', 24 },
    { 'z', 29 },
    { 'x', 30 },
    { 'c', 31 },
    { 'v', 32 },
    { 'b', 33 },
    { 'n', 34 },
    { 'm', 35 },
    { '1', 5 },
    { '2', 6 },
    { '3', 7 },
    { '4', 16 },
    { '5', 17 },
    { '6', 18 },
    { '7', 25 },
    { '8', 26 },
    { '9', 27 },
    { '0', 37 },
    { ',', 8 },
    { '.', 19 },
    { 'R', 8 }, // up arrow
    { 'Q', 19 }, // down arrow
    { 'P', 28 }, // left arrow
    { 'O', 39 }, // right arrow
};

#define KEYCODE_MAP_SZ (sizeof(keycode_map) / sizeof(keycode_map[0]))

static int find_key(char input)
{
    for (int i = 0; i < KEYCODE_MAP_SZ; i++) {
        if (keycode_map[i].input == input) {
            return keycode_map[i].key;
        }
    }
    return -1;
}

static void on_key_down(uint8_t code, uint32_t time, uint8_t repeat)
{
    //ESP_LOGD(TAG, "on_key_down code=%d (%c), time=%d, repeat=%d", code, code, time, repeat);
    int key = find_key(code);
    if (key != -1) {
        if (repeat) {
            // TODO: add state to provide accurate time, duration, repeat_count -- if neccessary
            uint32_t current_millis = ysw_get_millis();
            uint32_t duration = current_millis - down_time;
            ysw_event_key_pressed_t key_pressed = {
                .key = key,
                .time = down_time,
                .duration = duration,
                .repeat_count = repeat,
            };
            ysw_event_fire_key_pressed(cb_bus, &key_pressed);
        } else {
            down_time = ysw_get_millis(); // doesn't support n-key rollover
            ysw_event_key_down_t key_down = {
                .key = key,
                .time = down_time,
            };
            ysw_event_fire_key_down(cb_bus, &key_down);
        }
    }
}

static void on_key_up(uint8_t code, uint32_t time, uint8_t repeat)
{
    //ESP_LOGD(TAG, "on_key_up code=%d (%c), time=%d, repeat=%d", code, code, time, repeat);
    int key = find_key(code);
    if (key != -1) {
        uint32_t current_millis = ysw_get_millis();
        uint32_t duration = current_millis - down_time;
        ysw_event_key_pressed_t key_pressed = {
            .key = key,
            .time = current_millis,
            .duration = duration,
            .repeat_count = 0,
        };
        ysw_event_fire_key_pressed(cb_bus, &key_pressed);
        ysw_event_key_up_t key_up = {
            .key = key,
            .time = current_millis,
            .duration = duration,
            .repeat_count = 0,
        };
        ysw_event_fire_key_up(cb_bus, &key_up);
    }
}

void ysw_simulator_initialize(ysw_bus_h bus)
{
    cb_bus = bus;
    lv_key_down_handler = on_key_down;
    lv_key_up_handler = on_key_up;
}
